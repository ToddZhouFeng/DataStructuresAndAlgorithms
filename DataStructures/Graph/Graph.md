[TOC]



# 图 Graph

数据元素：**顶点 Vex** 

数据关系：对于两个顶点v, w，用<v, w>表示从v到w的一条**弧 Arc**。根据弧是否有方向分为**有向图 Digraph**和**无向图 Undiagragh**。对于有向图，v为**弧尾 Tail**或**初始点 Initial node**，w为**弧头 Head**或**终端点 Terminal node**。对于无向图，用 (v, w) 表示v, w之间的一条**边 Edge**

注：为了描述图的相关性质，定义如下术语：

* 子图：以原图中的部分顶点和边或弧构成的新的图
* 完全图 Completed graph：有n(n-1)/2条边的无向图，此时所有的顶点都相连。
* 有向完全图：有n(n-1)条弧的有向图，此时所有的顶点间都有两条弧。
* 稀疏图 Sparse gragh/稠密图Dense graph：有较少边或弧的图为稀疏图，反之为稠密图。根据需要定义“较少”（比如e<n log(n) ）
* 邻接点 Adjacent：在无向图中，若顶点v, w相连，则称其互为邻接点
* 度 Degree/入度InDegree/出度OutDegree：在无向图中，与顶点v相关联的边的数目，为v的度，记为TD(v)；在有向图中，以顶点v为头的弧的数目，为v的入度，记为ID(v)，以v为尾的弧的数目，为v的出度，记为OD(v)
* 路径 Path：一个顶点序列(v1, v2, v3, ... , vn)，表示从v1，依次从边或弧去到v2, v3, ...，最后到达vn。
* 回路、环 Cycle：第一个和最后一个顶点相同的路径
* 简单路径/简单回路：各顶点只出现一次的路径
* 连通图 Connected Graph：在无向图中，对于任意两个顶点v, w，都存在从v到w的路径
* 连通分量：无向图中的极大连通子图
* 强连通图：在有向图中，对于任意两个顶点v, w，都存在从v到w的路径
* 强连通分量：有向图中的极大强连通子图
* 生成树：一个极小连通子图，它包含图中所有n个顶点，但只有足以构成树的n-1条边
* 有向树：若一个有向图，只有一个顶点的入度为0，其余顶点的入度均为1，则为有向树
* 有向森林：由若干个有向树构成，并且包括所有顶点，以及足以构成有向树的弧

基本操作为：

```c++
//以顶点集vex和弧集arc构建图
createGraph(&graph, vex, arc);
//销毁图
destroyGraph(&graph);
//返回vex在图中的位置
locateVex(&graph, vex);
//获取vex的值
getVex(graph, vex);
//设置vex的值
putVex(&graph, vex, value);
//添加顶点vex
insertVex(&graph, vex);
//删除顶点vex
deleteVex(&graph, vex);
//添加弧
inseartArc(&graph, vex1, vex2, value);
//删除弧
deleteArc(&graph, vex1, vex2);
//深度优先遍历
DFSTraverse(&graph, Visit());
//广度优先遍历
BFSTraverse(&graph, Visit());
```



## 数组表示法

用一个数组储存数据元素的消息，用另一个数组储存边或弧的信息。后者称为**邻接矩阵**，规定第 i 行第 j 列表示从顶点 i 到 j 的弧（或度），1表示存在，0表示不存在。因此，第 i 行的和为元素 i 的出度，第 j 列的和为元素 j 的入度。

数组表示法适用于稠密图（e >> n(n-1)/2 ）



## 邻接表

**邻接表 Adjacency List** 是图的一种链式存储结构。对每个顶点建立一个单链表，里面的结点表示以该结点为尾的弧（有向图）或依附于该结点的边（无向图）。如果将结点改成 以该结点为头的弧（有向图），则称为**逆邻接表**。

表头结点一般以顺序结构存储。

邻接表适用于稀疏图（e << n(n-1)/2 ）



## 十字链表

**十字链表 Orthogonal List **是有向图的另一种链式存储结构。与邻接表不同的是，十字链表的结点有5个域：尾域tailvex、头域headvex、链域hlink、链域tlink、info域。头域指向弧头相同的下一个弧，尾域指向弧尾相同的下一个弧。

表头结点一般以顺序结构存储。

十字链表是邻接表域逆邻接表的结合。



## 邻接多重表

**邻接多重表 Adjacency Multilist **是无向图的另一种链式存储结构。因为在无向图的邻接表中，同一条弧被存储了两次，故仿照十字链表，将结点改为6个域：mark、结点ivex、ilink、结点jvex、jlink、info。ilink 指向下一条依附于 ivex 的边，jlink同理。mark用于标志这条边是否被搜索过（某些算法需要）。

表头结点一般以顺序结构存储。

邻接多重表是无向图的十字链表。



## 遍历

### 深度优先遍历 Depth_First Search

以一个顶点为起点，只要有路，就一直往前走；若没路，则退一步，换条路。若退到了起点还是没路，则换个起点。

一般需要借助一个数组标志顶点是否有被访问。

### 广度优先遍历 Broadth_First Search

以一个顶点为起点，先将周围的路都走一步，然后再走两步，......若没得走了，则换个起点。类似于树得层序遍历。

一般需要借助一个数组标志顶点是否有被访问。



## 连通性问题

### 求无向图的连通分量

根据深度优先遍历或广度优先遍历，可以画出深度优先生成树或广度优先生成树。有多少棵树，就有多少个连通分量。

### 求有向图得强连通分量

先广度优先遍历一次，得到一组顶点，然后再对这一组结点调用广度优先遍历......

### 最小生成树

从图中选出所有顶点和若干条边，构成一个树，边的权重和最小时，这种树称为最小生成树。

* 普里姆算法 Prim

  先以一个顶点为树的根，然后从该顶点的边中选一个权最小的边，将这条边和顶点加入到树；然后再从这两个顶点的所有边中选一个权最小的边，将这条边和顶点加入到树；不断重复这个过程，直到所有的顶点都加入都树中。注意：“权最小的边”是指已在树中的顶点的所有边的最小边，并且这个边连接的是未在树中的顶点。

  时间复杂度为 O( n^2 )，n为顶点的数目。

* 科鲁斯卡尔算法 Kruskal

  在图中找权最小的边，若加入到树中不会产生回路，则加入。不断重复这个过程，直到所有的顶点都加入都树中。

  时间复杂度为 O( e log e )，e为边的数目。


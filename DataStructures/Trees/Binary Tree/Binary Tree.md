[TOC]

# 二叉树 Binary Tree

数据元素：具有相同特征的数据元素的集合

数据关系：若数据元素为空，则二叉树为空二叉树；否则，二叉树满足
1. 存在惟一称为根的数据元素 root，
2. 除根元素外，其余元素可滑分为两个互不相交的集合
3. 在这两个集合中，只要集合不为空，就有且只有一个元素为 root，并且该集合也满足二叉树的数据关系
4. 这两个集合都是二叉树，其中一个称为 **左子树**，另一个称为**右子树**

基本操作：
```c++
//构造空二叉树
initBiTree( &T )
//销毁二叉树
destroyBiTree( &T )
//按照定义构造二叉树
createBiTree( &T, definition )
//清空二叉树
clearBiTree( &T )
//判断二叉树是否为空
biTreeEmpty( T )
//返回二叉树的深度
biTreeDepth( T )
//返回二叉树的根
root( T )
//返回结点e的值
value( T, e )
//为结点e赋值
assign( &T， &e, value)
//返回结点e的双亲
parent( T, e )
//返回结点e的左孩子
leftChild( T, e )
//返回结点e的右孩子
rightChild( T, e )
//返回结点e的左兄弟
leftSibling( T, e )
//返回结点e的右兄弟
rightSibling( T, e)
//插入左或右子树
insertChild( &T, &p, LR, c)
//删除左或右子树
deleteChild( &T, &p, LR)
//遍历二叉树，以下分别为先序，中序，后序，层序遍历
preOrderTraverse( T, visit() )
inOrderTraverse( T, visit() )
postOrderTraverse( T, visit() )
levelOrderTraverse( T, visit() )
```



## 特殊的二叉树

* 满二叉树：每一层的结点数都是最大结点数的二叉树
* 完全二叉树：除最后一层外，每一层的结点数都是最大结点数，并且最后一层的结点是从左到右无空排列时，称为完全二叉树（就是满二叉树去掉最后一层右边的结点）

![](https://img2018.cnblogs.com/blog/1311506/201809/1311506-20180914121949740-1126685097.png "特殊二叉树的示意图")



## 二叉树的基本性质

* 第 i 层至多有 2^( i-1 ) 个结点

  （容易证明）

* 深度为 k 的二叉树至多有 2^( k ) -1 个结点

  （等差数列）

* 若终端结点数为 m， 度为2的结点为 n，则 m = n+1

  （只有根结点时，m=1, n=0, 式子成立；之后每增加一个度为2的结点，必增加一个终端结点，故 m = n+1 ）

* 具有 n 个结点的完全二叉树的深度为⌊ log_2( n ) ⌋ +1

  （“⌊ n ⌋”表示n向下取整，“⌈ n ⌉”表示向上取整 。这条性质可通过性质2来证明）

* 若对一颗完全二叉树从 1 到 k 层，从左到右编号，则对任一结点 i ，有：

  * 如果 i>1 ，则其双亲结点为 ⌊ i/2 ⌋
  * 如果 2i<=n ，则其左孩子为 2i
  * 如果 2i+1<=n ，则其右孩子为 2i+1





## 二叉树的顺序存储

用一组连续的存储单元 依次从根到叶子，从左到右储存完全二叉树上的结点元素。对于一般的二叉树，则与完全二叉树对照，即使结点不存在，也要占用存储空间。



## 二叉树的链式存储

二叉树的链表的结点至少包括三个域：数据域、左指针域lchild、右指针域rchild，有时候会增加一个双亲的指针域。前者称为**二叉链表**后者称为**三叉链表**



## 二叉树的遍历

二叉树有三种遍历方法：

* 先序遍历：
  * 访问根结点
  * 先序遍历左子树
  * 先序遍历右子树
* 中序遍历：
  * 中序遍历左子树
  * 访问根结点
  * 中序遍历右子树
* 后序遍历：
  * 后序遍历左子树
  * 后序遍历右子树
  * 访问根结点

可以看出，这三种方法都采用的递归定义的方法，因此，我们可以用递归来编写相应的程序，也可以用栈。

先、中、后序遍历得到的序列分别称为：前缀表示（波兰式）、中缀表示、后缀表示（逆波兰式）。由任两个序列可以求出二叉树。



## 线索二叉树

二叉树中有些结点的指针域为空，为了充分利用储存空间，可以利用空指针域来储存遍历信息。方法如下：

* 在二叉链表的基础上，增加两个标志域 LTag 和RTag，若标志域为0，则表示对应指针域指示结点的左孩子（LTag=0）或右孩子（RTag=0）；若为1，则表示对应指针域指示前驱（LTag=1）或后继（RTag=1）。

这种存储结构称为**线索链表**，指向前驱或后继的指针叫做**线索**，加上线索的二叉树称为**线索二叉树**，通过某种遍历使二叉树变为线索二叉树的过程称为**线索化**。

有时候为了方便起见，会在线索链表上添加一个**头结点**，其lchild指针指向根结点，rchild指针指向**中序遍历访问的最后一个结点**；对应的，中序遍历的第一个结点的lchild指针指向头结点，最后一个结点的rchild指针指向头结点。这样，可以从第一个到最后一个进行遍历，也可以逆序进行遍历。



## 应用

### 二叉树表达式

表达式 = (第一操作数) (运算符) (第二操作数)，并规定，根结点的数据域存放运算符，左子树表示第一操作数，右子树表示第二操作数。